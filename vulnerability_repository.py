"""
Repository for Vulnerability database operations.

Implements repository pattern to abstract database access.
All database queries go through this class.

Methods:
- create: Insert new vulnerability
- get_by_id: Find by UUID
- get_by_cve: Find by CVE identifier
- list_by_severity: Filter by severity level
- update: Update existing record
- delete: Soft delete (mark as archived)
"""

from sqlalchemy import and_
from sqlalchemy.exc import SQLAlchemyError
from sqlalchemy.orm import Session

from ...shared.types import SeverityLevel, Vulnerability
from ..models import Vulnerability as VulnModel

# Allowed fields that can be updated via the update method
ALLOWED_UPDATE_FIELDS = {
    'cve_id', 'title', 'description', 'severity', 'cvss_score',
    'affected_versions', 'patched_versions', 'references', 'published_date',
    'last_modified', 'archived'
}


class VulnerabilityRepository:
    """Repository for managing vulnerability database operations."""

    def __init__(self, db: Session):
        """
        Initialize repository with database session.

        Args:
            db: SQLAlchemy database session
        """
        self.db = db

    def create(self, vulnerability: Vulnerability) -> VulnModel:
        """
        Insert new vulnerability into database.

        Args:
            vulnerability: Vulnerability object to create

        Returns:
            Created vulnerability model instance

        Raises:
            SQLAlchemyError: If database operation fails
        """
        try:
            vuln_model = VulnModel(**vulnerability.dict())
            self.db.add(vuln_model)
            self.db.commit()
            self.db.refresh(vuln_model)
            return vuln_model
        except SQLAlchemyError:
            self.db.rollback()
            raise

    def get_by_id(self, vuln_id: str) -> VulnModel | None:
        """
        Find vulnerability by UUID.

        Args:
            vuln_id: UUID of the vulnerability

        Returns:
            Vulnerability model if found, None otherwise
        """
        return (
            self.db.query(VulnModel)
            .filter(and_(VulnModel.id == vuln_id, VulnModel.archived is False))
            .first()
        )

    def get_by_cve(self, cve_id: str) -> VulnModel | None:
        """
        Find vulnerability by CVE identifier.

        Args:
            cve_id: CVE identifier (e.g., CVE-2024-1234)

        Returns:
            Vulnerability model if found, None otherwise
        """
        return (
            self.db.query(VulnModel)
            .filter(and_(VulnModel.cve_id == cve_id, VulnModel.archived is False))
            .first()
        )

    def list_by_severity(self, severity: SeverityLevel) -> list[VulnModel]:
        """
        Filter vulnerabilities by severity level.

        Args:
            severity: Severity level to filter by

        Returns:
            List of vulnerability models matching the severity level
        """
        return (
            self.db.query(VulnModel)
            .filter(and_(VulnModel.severity == severity, VulnModel.archived is False))
            .all()
        )

    def update(self, vuln_id: str, updates: dict) -> VulnModel | None:
        """
        Update existing vulnerability record.

        Args:
            vuln_id: UUID of the vulnerability to update
            updates: Dictionary of fields to update (only allowed fields will be updated)

        Returns:
            Updated vulnerability model if found, None otherwise

        Raises:
            ValueError: If updates dictionary contains invalid fields
            SQLAlchemyError: If database operation fails
        """
        # Validate that all keys in updates are allowed
        invalid_fields = set(updates.keys()) - ALLOWED_UPDATE_FIELDS
        if invalid_fields:
            raise ValueError(f"Invalid fields in updates: {invalid_fields}")

        vuln = self.get_by_id(vuln_id)
        if vuln:
            try:
                for key, value in updates.items():
                    if hasattr(vuln, key):
                        setattr(vuln, key, value)
                self.db.commit()
                self.db.refresh(vuln)
            except SQLAlchemyError:
                self.db.rollback()
                raise
        return vuln

    def delete(self, vuln_id: str) -> bool:
        """
        Soft delete vulnerability by marking as archived.

        Args:
            vuln_id: UUID of the vulnerability to delete

        Returns:
            True if deleted successfully, False if not found

        Raises:
            SQLAlchemyError: If database operation fails
        """
        vuln = self.get_by_id(vuln_id)
        if vuln:
            try:
                vuln.archived = True
                self.db.commit()
                return True
            except SQLAlchemyError:
                self.db.rollback()
                raise
        return False
