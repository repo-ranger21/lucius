"""
Business logic layer for vulnerability management.

Handles:
- Vulnerability creation with ML scoring
- Duplicate detection and merging
- Notification triggering
- Report generation
- Integration with external CVE databases

This layer sits between API routes and repositories.
"""

from typing import List, Dict, Optional, Tuple
from datetime import datetime
from uuid import UUID

from talon.extensions import db
from talon.models import Vulnerability as VulnModel, ScanResult, ScanVulnerability
from shared.types import Vulnerability, Severity
from .threat_scoring import ThreatScoringService
from .notification_service import NotificationService
from shared.logging import get_logger

logger = get_logger(__name__)


class VulnerabilityService:
    """
    Business logic layer for vulnerability management.

    Handles vulnerability lifecycle from creation to remediation tracking.
    Integrates ML-based threat scoring and multi-channel notifications.
    """

    def __init__(self):
        """Initialize service with required dependencies."""
        self.threat_scorer = ThreatScoringService()
        self.notification_service = NotificationService()

    def create_vulnerability(
        self,
        cve_id: str,
        severity: str,
        description: str = "",
        cvss_score: Optional[float] = None,
        cvss_vector: Optional[str] = None,
        affected_packages: Optional[List[Dict]] = None,
        references: Optional[List[Dict]] = None,
        published_date: Optional[datetime] = None,
        modified_date: Optional[datetime] = None,
        calculate_threat: bool = True,
    ) -> VulnModel:
        """
        Create a new vulnerability with ML-based threat scoring.

        Args:
            cve_id: CVE identifier (e.g., CVE-2024-1234)
            severity: Severity level (CRITICAL, HIGH, MEDIUM, LOW)
            description: Vulnerability description
            cvss_score: CVSS base score (0-10)
            cvss_vector: CVSS vector string
            affected_packages: List of affected package details
            references: List of reference URLs
            published_date: Publication date
            modified_date: Last modification date
            calculate_threat: Whether to calculate threat score

        Returns:
            Created vulnerability model

        Raises:
            ValueError: If CVE already exists
        """
        # Check for duplicates
        existing = self.get_by_cve(cve_id)
        if existing:
            logger.warning(f"Vulnerability {cve_id} already exists")
            raise ValueError(f"Vulnerability {cve_id} already exists")

        # Create vulnerability object
        vuln_data = Vulnerability(
            cve_id=cve_id,
            severity=Severity(severity),
            description=description,
            cvss_score=cvss_score,
            cvss_vector=cvss_vector,
            affected_packages=affected_packages or [],
            references=[],
            published_date=published_date,
            modified_date=modified_date,
        )

        # Calculate threat score
        threat_score = None
        if calculate_threat:
            threat_score, factors = self.threat_scorer.calculate_threat_score(vuln_data)
            logger.info(f"Calculated threat score for {cve_id}: {threat_score}")

        # Create database record
        vuln_model = VulnModel(
            cve_id=cve_id,
            severity=severity,
            description=description,
            cvss_score=cvss_score,
            cvss_vector=cvss_vector,
            affected_packages=affected_packages or [],
            references=references or [],
            published_date=published_date,
            modified_date=modified_date,
            threat_score=threat_score,
        )

        db.session.add(vuln_model)
        db.session.commit()
        db.session.refresh(vuln_model)

        # Trigger high-severity notifications
        if severity in ["CRITICAL", "HIGH"] or (threat_score and threat_score >= 70):
            self._trigger_vulnerability_alert(vuln_model)

        logger.info(f"Created vulnerability {cve_id} with threat score {threat_score}")
        return vuln_model

    def get_by_cve(self, cve_id: str) -> Optional[VulnModel]:
        """
        Get vulnerability by CVE identifier.

        Args:
            cve_id: CVE identifier

        Returns:
            Vulnerability model if found, None otherwise
        """
        return VulnModel.query.filter_by(cve_id=cve_id).first()

    def get_by_id(self, vuln_id: UUID) -> Optional[VulnModel]:
        """
        Get vulnerability by UUID.

        Args:
            vuln_id: Vulnerability UUID

        Returns:
            Vulnerability model if found, None otherwise
        """
        return VulnModel.query.filter_by(id=vuln_id).first()

    def find_or_create(
        self,
        cve_id: str,
        severity: str,
        description: str = "",
        **kwargs
    ) -> Tuple[VulnModel, bool]:
        """
        Find existing vulnerability or create new one.

        Args:
            cve_id: CVE identifier
            severity: Severity level
            description: Vulnerability description
            **kwargs: Additional vulnerability fields

        Returns:
            Tuple of (vulnerability_model, was_created)
        """
        existing = self.get_by_cve(cve_id)
        if existing:
            return existing, False

        vuln = self.create_vulnerability(
            cve_id=cve_id,
            severity=severity,
            description=description,
            **kwargs
        )
        return vuln, True

    def update_vulnerability(
        self,
        vuln_id: UUID,
        updates: Dict,
        recalculate_threat: bool = False,
    ) -> Optional[VulnModel]:
        """
        Update existing vulnerability.

        Args:
            vuln_id: Vulnerability UUID
            updates: Dictionary of fields to update
            recalculate_threat: Whether to recalculate threat score

        Returns:
            Updated vulnerability model if found, None otherwise
        """
        vuln = self.get_by_id(vuln_id)
        if not vuln:
            logger.warning(f"Vulnerability {vuln_id} not found for update")
            return None

        # Update fields
        for key, value in updates.items():
            if hasattr(vuln, key):
                setattr(vuln, key, value)

        vuln.updated_at = datetime.utcnow()

        # Recalculate threat score if requested
        if recalculate_threat:
            vuln_obj = self._model_to_dataclass(vuln)
            threat_score, factors = self.threat_scorer.calculate_threat_score(vuln_obj)
            vuln.threat_score = threat_score
            logger.info(f"Recalculated threat score for {vuln.cve_id}: {threat_score}")

        db.session.commit()
        db.session.refresh(vuln)

        return vuln

    def list_by_severity(
        self,
        severity: str,
        limit: int = 100,
        offset: int = 0,
    ) -> List[VulnModel]:
        """
        List vulnerabilities by severity level.

        Args:
            severity: Severity level to filter by
            limit: Maximum number of results
            offset: Number of results to skip

        Returns:
            List of vulnerability models
        """
        return VulnModel.query.filter_by(
            severity=severity
        ).order_by(
            VulnModel.threat_score.desc().nullslast(),
            VulnModel.created_at.desc()
        ).limit(limit).offset(offset).all()

    def list_high_threat(
        self,
        threshold: float = 70.0,
        limit: int = 100,
    ) -> List[VulnModel]:
        """
        List high-threat vulnerabilities above threshold.

        Args:
            threshold: Minimum threat score (0-100)
            limit: Maximum number of results

        Returns:
            List of vulnerability models ordered by threat score
        """
        return VulnModel.query.filter(
            VulnModel.threat_score >= threshold
        ).order_by(
            VulnModel.threat_score.desc()
        ).limit(limit).all()

    def detect_duplicates(self, cve_id: str) -> List[VulnModel]:
        """
        Detect potential duplicate vulnerabilities.

        Args:
            cve_id: CVE identifier to check

        Returns:
            List of potential duplicate vulnerability models
        """
        # Exact CVE match
        exact = VulnModel.query.filter_by(cve_id=cve_id).all()

        # Could add fuzzy matching logic here for similar CVEs
        # e.g., CVE-2024-1234 vs CVE-2024-1234A

        return exact

    def merge_vulnerabilities(
        self,
        primary_id: UUID,
        duplicate_id: UUID,
    ) -> VulnModel:
        """
        Merge duplicate vulnerability into primary record.

        Updates all scan references to point to primary vulnerability,
        then marks duplicate as archived.

        Args:
            primary_id: Primary vulnerability UUID to keep
            duplicate_id: Duplicate vulnerability UUID to merge

        Returns:
            Updated primary vulnerability model

        Raises:
            ValueError: If vulnerabilities not found or are the same
        """
        primary = self.get_by_id(primary_id)
        duplicate = self.get_by_id(duplicate_id)

        if not primary or not duplicate:
            raise ValueError("One or both vulnerabilities not found")

        if primary_id == duplicate_id:
            raise ValueError("Cannot merge vulnerability with itself")

        # Update all scan references
        ScanVulnerability.query.filter_by(
            vulnerability_id=duplicate_id
        ).update({"vulnerability_id": primary_id})

        # Merge metadata if needed
        if duplicate.references:
            merged_refs = primary.references + duplicate.references
            # Deduplicate references
            unique_refs = []
            seen_urls = set()
            for ref in merged_refs:
                if ref.get("url") not in seen_urls:
                    unique_refs.append(ref)
                    seen_urls.add(ref.get("url"))
            primary.references = unique_refs

        # Delete duplicate
        db.session.delete(duplicate)
        db.session.commit()
        db.session.refresh(primary)

        logger.info(f"Merged {duplicate.cve_id} into {primary.cve_id}")
        return primary

    def generate_report(
        self,
        severity_levels: Optional[List[str]] = None,
        min_threat_score: Optional[float] = None,
        start_date: Optional[datetime] = None,
        end_date: Optional[datetime] = None,
    ) -> Dict:
        """
        Generate vulnerability report with statistics.

        Args:
            severity_levels: Filter by severity levels
            min_threat_score: Minimum threat score threshold
            start_date: Filter by publication start date
            end_date: Filter by publication end date

        Returns:
            Dictionary containing report data and statistics
        """
        query = VulnModel.query

        # Apply filters
        if severity_levels:
            query = query.filter(VulnModel.severity.in_(severity_levels))

        if min_threat_score is not None:
            query = query.filter(VulnModel.threat_score >= min_threat_score)

        if start_date:
            query = query.filter(VulnModel.published_date >= start_date)

        if end_date:
            query = query.filter(VulnModel.published_date <= end_date)

        vulnerabilities = query.all()

        # Calculate statistics
        total_count = len(vulnerabilities)
        severity_breakdown = {
            "CRITICAL": 0,
            "HIGH": 0,
            "MEDIUM": 0,
            "LOW": 0,
            "UNKNOWN": 0,
        }

        threat_scores = []
        for vuln in vulnerabilities:
            severity_breakdown[vuln.severity] += 1
            if vuln.threat_score:
                threat_scores.append(float(vuln.threat_score))

        report = {
            "generated_at": datetime.utcnow().isoformat(),
            "total_vulnerabilities": total_count,
            "severity_breakdown": severity_breakdown,
            "threat_score_stats": {
                "min": min(threat_scores) if threat_scores else None,
                "max": max(threat_scores) if threat_scores else None,
                "avg": sum(threat_scores) / len(threat_scores) if threat_scores else None,
            },
            "filters": {
                "severity_levels": severity_levels,
                "min_threat_score": min_threat_score,
                "start_date": start_date.isoformat() if start_date else None,
                "end_date": end_date.isoformat() if end_date else None,
            },
            "vulnerabilities": [v.to_dict() for v in vulnerabilities[:100]],  # Limit to 100
        }

        logger.info(f"Generated report with {total_count} vulnerabilities")
        return report

    def enrich_from_cve_database(self, cve_id: str) -> Optional[VulnModel]:
        """
        Enrich vulnerability with data from external CVE databases.

        This method would integrate with APIs like:
        - NVD (National Vulnerability Database)
        - CVE.org
        - MITRE

        Args:
            cve_id: CVE identifier to enrich

        Returns:
            Enriched vulnerability model if found, None otherwise
        """
        vuln = self.get_by_cve(cve_id)
        if not vuln:
            logger.warning(f"Vulnerability {cve_id} not found for enrichment")
            return None

        # Placeholder for external API integration
        # In production, this would:
        # 1. Query NVD API for CVE details
        # 2. Extract CVSS scores, vectors, references
        # 3. Update vulnerability record
        # 4. Recalculate threat score

        logger.info(f"Enrichment for {cve_id} not implemented (requires external API)")
        return vuln

    def _trigger_vulnerability_alert(self, vuln: VulnModel) -> None:
        """
        Trigger alert notifications for high-severity vulnerabilities.

        Args:
            vuln: Vulnerability model to alert on
        """
        try:
            self.notification_service.send_alert(
                title=f"New {vuln.severity} Vulnerability: {vuln.cve_id}",
                message=self._format_vulnerability_message(vuln),
                severity=vuln.severity.lower(),
                channels=["slack"],
            )
            logger.info(f"Sent alert for vulnerability {vuln.cve_id}")
        except Exception as e:
            logger.error(f"Failed to send alert for {vuln.cve_id}: {e}")

    def _format_vulnerability_message(self, vuln: VulnModel) -> str:
        """Format vulnerability details for notifications."""
        lines = [
            f"*CVE:* {vuln.cve_id}",
            f"*Severity:* {vuln.severity}",
        ]

        if vuln.cvss_score:
            lines.append(f"*CVSS Score:* {vuln.cvss_score}/10")

        if vuln.threat_score:
            lines.append(f"*Threat Score:* {vuln.threat_score}/100")

        if vuln.description:
            lines.append(f"\n{vuln.description[:300]}")

        if vuln.affected_packages:
            lines.append(f"\n*Affected Packages:* {len(vuln.affected_packages)}")

        return "\n".join(lines)

    def _model_to_dataclass(self, model: VulnModel) -> Vulnerability:
        """Convert database model to dataclass for threat scoring."""
        return Vulnerability(
            cve_id=model.cve_id,
            severity=Severity(model.severity),
            description=model.description or "",
            cvss_score=float(model.cvss_score) if model.cvss_score else None,
            cvss_vector=model.cvss_vector,
            affected_packages=model.affected_packages or [],
            references=[],
            published_date=model.published_date,
            modified_date=model.modified_date,
            threat_score=float(model.threat_score) if model.threat_score else None,
        )
